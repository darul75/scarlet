  <!-- CONTENT CONTAINER -->

  <div 
    id="leftContainer" 
    x-type="x-panel" 
    x-width="100%">

    <!-- CONTENT -->
    
    <div 
      id="helpTitle" 
      class="x-title">
      <b>Prototypes</b> - { Object.create(myType); }
    </div>

    <div 
      id="helpContent"
      x-type="x-panel"
      x-padding="15px"
      class="x-content">
      
      <i 
        id="helpLogo" 
        x-type="x-panel" 
        x-float="left" 
        x-margin="4px"
        class="fa fa-code fa-2x">
      </i> 
      
      <div x-shell-addref class="hidden">
function Comment(content, email) {
  var self = this;
  self.email = email;
  self.content = content;
  self.created = new Date();
}

function Blog(title, content, author) {
  var self = this;
  self.comments = [];
  self.title = title;
  self.author = author;
  self.content = content;
  self.created = new Date();
  self.addComment = function(comment){
    self.comments.push(comment);
  };
}</div>

      <h1><a name="prototypesLink">Prototypes</a></h1>
      
      <p>Here we take a look at using <b><i>Scarlet</b></i> with JavaScript prototypes(or javascript objects). Scarlet is really good at discovering constructors, properties and methods of instances and prototype definitions using the same API.</p>
      
      <div class="x-spacer-alt x-clear"></div>

      <h4><a name="prototypesLink">An Object</a></h4>

      <p>For the purposes of the rest of this article let's assume an example prototype. Let's say we run a blog. We have a <b><i>Comment</b></i> which is what users who read the blog leave behind and the <b><i>Blog</i></b> article itself, composed out of a <b><i>title</b></i> and <b><i>content</b></i> properties. Lets define and instantiate them. They will be omitted from the rest of the examples in this page just trust that they magically exist :) </p>

      <div 
        id="prototypeExampleObjectEditor" 
        class="x-border"
        x-type="x-editor" 
        x-width="100%"
        x-height="385px" 
        x-margin="10px"
        x-run-onload="true"
        x-output="#prototypeExampleObjectOutput">
function Comment(content, email) {
  var self = this;
  self.email = email;
  self.content = content;
  self.created = new Date();
}

function Blog(title, content, author) {
  var self = this;
  self.comments = [];
  self.title = title;
  self.author = author;
  self.content = content;
  self.created = new Date();
  self.addComment = function(comment){
    self.comments.push(comment);
  };
}

var anyBlog = new Blog("Example", "Hello World!", "anonymous");
anyBlog.addComment(new Comment("buuuurrrrrrp!", "beer@ticktockdevelopment.com"));
print("Completed creating objects!");
</div>

      <!-- THIS INDENT FOR NEXT -->
      <div 
        id="prototypeExampleObjectOutput" 
        class="x-border x-output"
        x-type="x-output"
        x-margin="10px"
        x-width="100%"
        x-height="19px">
      </div>

      <div class="x-spacer-alt x-clear"></div>

      <h4><a name="prototypesWithScarletLink">Logging</a></h4>

      <p>Now we are going to use <b><i>Scarlet</b></i> to build a naive logging interceptor. We will run the Blog prototype through Scarlet and use it's proxy for instantiating the same <b><i>anyBlog</i></b> you saw in the earlier code example. When we run the example we should see output relating to how the interceptor get's called.</p>

      <div 
        id="prototypeExampleWithScarletObjectEditor" 
        class="x-border"
        x-type="x-editor" 
        x-width="100%"
        x-height="554px" 
        x-margin="10px"
        x-run-onload="true"
        x-output="#prototypeExampleWithScarletObjectOutput">
var scarlet = new Scarlet();

function formatMember(info, args){
  if (info.type.isConstructor) 
    return "ctor";
  if (info.type.isProperty &amp;&amp; (args &amp;&amp; args.length === 1))
    return "get prop '" + info.memberName + "'";
  if (info.type.isProperty &amp;&amp; (args &amp;&amp; args.length === 2))
    return "set prop '" + info.memberName + "'='" + args[1]+ "'";
  return "member '" + info.memberName + "'";
}

function formatArgs(result){
  return !_.isEmpty(result) ? "with " + JSON.stringify(result) : "";
}

function logger(info, method, args){
  var result = method.call(this, info, method, args);
  print(formatMember(info, args) + " " + formatArgs(args) + " " + formatArgs(result));
  return result;
}

var Blog = scarlet
  .intercept(Blog, scarlet.PROTOTYPE)
  .using(logger)
  .proxy();

var anyBlog = new Blog("Example", "Hello World!", "anonymous");
anyBlog.addComment(new Comment("buuuurrrrrrp!", "beer@ticktockdevelopment.com"));
anyBlog.title = "Updated Example";
anyBlog.content = "Updated Content";
print("Completed creating objects!");
</div>

      <!-- THIS INDENT FOR NEXT -->
      <div 
        id="prototypeExampleWithScarletObjectOutput" 
        class="x-border x-output"
        x-type="x-output"
        x-margin="10px"
        x-width="100%"
        x-height="93px">
      </div>


      <p>
        See how easy it is to determine whether you are intercepting <b><i>constructors</b></i>, <b><i>properties</b></i> or <b><i>methods</b></i> using the <b><i>info</b></i> parameter? Here we have effectively implemented a logger as a cross cutting concern. The reason is because <b><i>Blog</b></i> prototype's code does not actually know anything about logger. 
      </p>

    </div>

  </div>

</div>
